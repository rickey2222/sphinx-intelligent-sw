<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>梯度拓扑优化算法 &mdash; 微纳光学智能设计软件 v1 文档</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/translations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="远场传播模块" href="../%E8%BF%9C%E5%9C%BA%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%9D%97/contents.html" />
    <link rel="prev" title="全局搜索优化算法" href="../%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9D%97/contents.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> 微纳光学智能设计软件
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">软件平台简介</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/index.html">智能软件平台建设</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">核心设计优化算法</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9D%97/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B.html">深度学习算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../%E6%95%B0%E5%80%BC%E4%BB%BF%E7%9C%9F%E6%A8%A1%E5%9D%97/%E6%95%B0%E5%80%BC%E4%BB%BF%E7%9C%9F%E7%AE%97%E6%B3%95.html">数值仿真算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9D%97/contents.html">全局搜索优化算法</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">梯度拓扑优化算法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">1. 逆向设计介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">2. 基于密度的拓扑优化算法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">3. 基于水平集的拓扑优化算法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">4. 添加制造限制约束</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../%E8%BF%9C%E5%9C%BA%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%9D%97/contents.html">远场传播模块</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/index.html">软件安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/index.html">软件模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../%E8%BD%AF%E4%BB%B6API%E6%8E%A5%E5%8F%A3/contents.html">软件API接口</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">微纳光学智能设计软件</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">软件平台简介</a></li>
          <li class="breadcrumb-item"><a href="../index.html">核心设计优化算法</a></li>
      <li class="breadcrumb-item active">梯度拓扑优化算法</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/简介/核心设计优化算法/梯度拓扑优化模块/梯度拓扑优化算法.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>梯度拓扑优化算法<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<section id="id2">
<h2>1. 逆向设计介绍<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<section id="id3">
<h3>1.1 逆向设计算法框架介绍<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>  逆向设计是实现超紧凑、高性能、新功能集成硅光子器件极具吸引力的新型方法。逆向设计过程中，已知输入与输出参数，通过对设计区域参数的修改得到相对理想的结果。<br>
  如图1.1(a)所示，在常规（前向）设计中，已知输入 <span class="math notranslate nohighlight">\(x_n\)</span>(n为自然数)，且输出 <span class="math notranslate nohighlight">\(y_n\)</span>与输入 <span class="math notranslate nohighlight">\(x_n\)</span>之间存在约束式<span class="math notranslate nohighlight">\(F_n\)</span>,在设计中给定设计区参数<span class="math notranslate nohighlight">\(ρ_n\)</span>,得到输出<span class="math notranslate nohighlight">\(y_n=F_n(x_n,ρ_n)\)</span>。
在对输出结果进行优化时，通过多次改变设计区参数<span class="math notranslate nohighlight">\(ρ_n\)</span>（如粒子群优化算法），得到依据于初始参数的最优解。<br>
  如图1.1(b)所示，在逆向设计中，设计模型由方程组<span class="math notranslate nohighlight">\(F_n(x_n,ρ_n)=y_n\)</span>表示，已知输入<span class="math notranslate nohighlight">\(x_n\)</span>以及希望得到的输出<span class="math notranslate nohighlight">\(y_n\)</span>,对<span class="math notranslate nohighlight">\(F_n(x_n,ρ_n)=y_n\)</span>求解，得到设计区参数<span class="math notranslate nohighlight">\(\hat{p}_n\)</span>。
在对输出结果进行优化时，通过多次比价输出<span class="math notranslate nohighlight">\(\hat{y}_n\)</span>与希望得到的输出<span class="math notranslate nohighlight">\(y_n\)</span>之间的差值，改变设计区参数<span class="math notranslate nohighlight">\(\hat{p}_n\)</span>，使输出结果接近输出<span class="math notranslate nohighlight">\(y_n\)</span>,得到设计参数<span class="math notranslate nohighlight">\(ρ_n\)</span>的最优解。
<span><div style="text-align: center;"></p>
<p><img alt="1.1.png" src="../../../_images/1.1.png" /></p>
</div></span>
<center>图1.1(a)前向设计流程示意图；(b)逆向设计流程示意图</center>
</section>
<section id="id4">
<h3>1.2 基于梯度下降的伴随法介绍<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>  伴随法是一种用于在数值优化问题中有效计算函数或算子的梯度的数值方法。基于梯度下降的伴随法具有迭代次数少，仿真时间短等优点。<br>
  如图1.1.所示,在优化过程中，依据约束方程组<span class="math notranslate nohighlight">\(F_n(x_n,y_n)\)</span>构建度量函数<span class="math notranslate nohighlight">\(G_n(x_n,ρ_n)\)</span>，度量函数<span class="math notranslate nohighlight">\(G_n\)</span>用来描述设计参数<span class="math notranslate nohighlight">\(\hat{ρ}_n\)</span>时，对应的输出<span class="math notranslate nohighlight">\(\hat{y}_n\)</span>,与目标输出<span class="math notranslate nohighlight">\(y_n\)</span>的距离，当<span class="math notranslate nohighlight">\(G_n(x_n,ρ_n)\)</span>取最小值时，即可认为取得了涉及区域的最优解。<br>
  由于<span class="math notranslate nohighlight">\(G_n(x_n,ρ_n)=min\)</span>为不易求解的方程，考虑到其参数与约束条件<span class="math notranslate nohighlight">\(F_n(x_n,ρ_n)\)</span>相同，构建拉格朗日函数，对函数L关于<span class="math notranslate nohighlight">\(ρ_n\)</span>求解偏微分，当偏微分为零时，取得的含有拉格朗日乘子的等式即为伴随等式，伴随式在物理意义上等价于将所需的输出对场强的导数注入系统，并逆向运行系统得到的输出结果。<br>
  对<span class="math notranslate nohighlight">\(G_n(x_n,ρ_n)\)</span>关于<span class="math notranslate nohighlight">\(ρ_n\)</span>求解偏微分，可得当对设计区参数<span class="math notranslate nohighlight">\(ρ_n\)</span>进项微小扰动时对输出结果的影响程度，即梯度。梯度在数学上等价于前向仿真在设计区得到的数值与伴随仿真的数值乘积的实部。梯度对着迭代次数减小，即可得到<span class="math notranslate nohighlight">\(G_n(x_n,ρ_n)\)</span>的最小值。
<span><div style="text-align: center;">
<img alt="1.2.png" src="../../../_images/1.2.png" /></p>
</div></span>
<center>图1.2 基于梯度下降的伴随优化算法</center>
</section>
</section>
<section id="id5">
<h2>2. 基于密度的拓扑优化算法<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h2>
<p>  基于密度的拓扑优化对每个像素的设计进行参数化，使每个像素要么是“固体”（一种高的折射率材料），“空隙”（一种地折射率的材料），要么是两者之间的一些非物理插值。
一系列涉及过滤器和投影的转换用来逐步二值化设计，使其所有都是实的或者空的，通常也可以施加各种优化约束来强制执行设计规则（比如最小长度尺寸、面积和曲率）。
这种基于密度的拓扑优化算法是允许像素在优化过程中采用虚拟的插值材料“密度”，因此得到的目标函数（及其梯度）是平滑和连续可微的，这是基于梯度优化算法的一个重要要求，
相比于水平集的优化算法，它在求微分和优化过程中更胜一筹。</p>
<section id="id6">
<h3>2.1 过滤<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<p>  拓扑优化中时常会伴随着网格依赖性、棋盘格以及灰度单元过多等现象。这些现象会导致实体与空洞交接模糊不清，影响材料识别，为了得到如下图2.1所示那样的清晰的优化构型，目前常用的解决方法是先通过过滤，密度过滤的主要思想是修改细胞的密度，从而影响目标器件性能，使其依赖于给定领域内的密度场。
滤波是通过使用滤波器函数和密度的卷积乘积来实现的。
但是过滤之后会导致实体与空洞交界处灰度单元的增加，所以还需要通过Heaviside投影得到清晰的优化构型。
<span><div style="text-align: center;">
<img alt="2.1.png" src="../../../_images/2.1.png" /></p>
</div></span>
<center>图2.1 过滤及投影过程</center>
</section>
<section id="id7">
<h3>2.2 投影<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<p>  得到经过过滤的密度场之后，对其进行基于光滑的Heaviside函数的投影操作，得到投影后的密度。关于Heaviside函数的表达式如下：<br></p>
<div class="math notranslate nohighlight">
\[\bar{ρ}_i=\frac{tanh(βη)+tanh(β(\tilde{ρ}_i-η))}{tanh(βη)+tanh(β(1-η))}\]</div>
<p>  其函数中的参数η为投影阈值，即当单元密度小于η时，则Heaviside函数将改单元的密度向0方向投影；反之，当单元密度大于η时，则Heaviside函数将该单元的密度向1方向投影。其中参数β控制着Heaviside函数在阈值参数η附近的陡峭程度，当β趋近于无穷时，Heaviside函数则接近为阶跃函数。</p>
</section>
</section>
<section id="id8">
<h2>3. 基于水平集的拓扑优化算法<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h2>
<section id="id9">
<h3>3.1 水平集方法思想<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h3>
<p>  水平集的基本思想是将界面看成高一维空间中某一函数<span class="math notranslate nohighlight">\(φ(x)\)</span>的零水平集，同时界面的演化也扩充到高一维的空间中。我们将水平集函数按照它所满足的发展方程进行的演化或迭代，由于水平集函数不断进行演化，所以零水平集也在不断变化，当水平集演化趋于平稳时，演化停止，得到界面形状,如图3.1所示。
<span><div style="text-align: center;"></p>
<p><img alt="水平集" src="../../../_images/3.1.jpg" /></p>
</div></span>
<center>图3.1 水平集表示</center>
</section>
<section id="id10">
<h3>3.2 水平集拓扑优化流程<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<section id="id11">
<h4>3.2.1 构建初始水平集函数<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<p>  在水平集方法中，设计边界由水平集函数<span class="math notranslate nohighlight">\(φ(x)\)</span>的零水平轮廓定义，结构是由水平集函数取正值的域定义，进行材料的初始分布，即：<br></p>
<div class="math notranslate nohighlight">
\[\begin{split}     ρ=\begin{cases}0,&amp; ∀x∈Ω；φ&lt;0 \\ 1,&amp; ∀x∈Ω；φ≥0 \end{cases}\end{split}\]</div>
</section>
<section id="id12">
<h4>3.3.2 构建拉格朗日函数<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<p>  根据设计目标和制造约束来构建拉格朗日函数，如下：</p>
<div class="math notranslate nohighlight">
\[    L(x)=J(x)+λx(V(x)-V_{max}) +\frac{1}{2Λ}(V(x)-V_{max})^2\]</div>
<p>  其中，J(x)是优化目标函数，<span class="math notranslate nohighlight">\(V(x)-V_{max}\)</span>是给定的等式约束，λ和Λ是两个拉格朗日系数，更新策略为：</p>
<div class="math notranslate nohighlight">
\[    λ^{k+1}=λ^{k}+\frac{1}{Λ^k}(V(x)-V_{max})Λ^{k+1}=αΛ^k\]</div>
<p>  其中，权重系数<span class="math notranslate nohighlight">\(α∈(0,1)\)</span>。</p>
</section>
</section>
<section id="id13">
<h3>3.3.3 更新水平集函数<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h3>
<p>  最常见的水平集函数更新通过哈密顿-雅可比方程来解决：</p>
<div class="math notranslate nohighlight">
\[    \frac{\partial φ}{\partial t}+V(x)|\nabla φ| =0\]</div>
<p>  在优化过程中，t是一个伪时间代表设计的演变，v是所谓的速度函数，或速度场，<span class="math notranslate nohighlight">\(\nabla φ\)</span>为水平集函数的梯度。边界的动态变化被水平集函数控制。根据新的水平集函数确定新的材料分布和新的拉格朗日函数。</p>
</section>
</section>
<section id="id14">
<h2>4. 添加制造限制约束<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h2>
<p>基于拓扑优化的光子逆向设计是一种强大的器件设计方法，在这种方法中，性能（如传输功率）可以优化数千或数百万自由度，表征制造器件的每个“像素”，允许完全意想不到的设计与前所未有的性能出现。然而，拓扑优化的巨大设计自由必须受到实际制造过程的限制，能满足那些商业半导体铸造厂的工艺约束，如图1所示。因此，本软件基于经典的密度的拓扑优化框架，施加了最小线宽、线间隔和曲率，最小面积和最小封闭面积约束，所有这些都没有实现任何额外的重新参数化。
<span><div style="text-align: center;">
<img alt="五种设计规则" src="../../../_images/4.1.png" /></p>
</div></span>
<center>图4.1 半导体铸造厂的五种基本设计规则约束。一维约束包括线宽限制(a)、间隙限制(b)和曲率半径限制(c),二维约束包括面积限制(d)和封闭面积限制(e),在超表面拓扑单元结构中违反DRC的例子用各自的颜色(f)突出显示</center>
<section id="id15">
<h3>4.1 添加最小线宽，最小间隙，最小曲率半径约束<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h3>
<p>在拓扑的固体和空隙区域上强制执行最小的长度尺度。这些特殊的约束完全对应于一个铸造厂的设计规则手册的最小线宽和最小线间隔约束。约束通过识别拐点区域来工作，这些区域决定了在战略选择的侵蚀和扩张后设计拓扑是否保持不变。如果拓扑结构是一致的（即没有额外的“孔”或“岛”），那么就满足了长度尺度。强制执行实现此过程的优化约束需要一个指示符函数能够识别拐点区域和过滤器核和必要的侵蚀/膨胀之间的已知关系，最小线宽约束<span class="math notranslate nohighlight">\(g_{Lw}≤0\)</span>由该函数描述：</p>
<div class="math notranslate nohighlight">
\[g_{Lw}=\frac{1}{n}\sum_{i∈N} I_i^{Lw}(ρ_i)·[min{(\tilde{\rho_i}-η_e),0}]^2\]</div>
<p>其中，IiLW(ρ)是一个指示函数，用来识别固相的变化区域：</p>
<div class="math notranslate nohighlight">
\[I_i^{Lw}(\rho)=\bar{\rho}·exp(-c\left| \nabla{\tilde{\rho}} \right|^2)\]</div>
<p>其中，c是指示指标函数的“强度”的阻尼项。最小线间隔约束，gLS≤0，用一个类似的函数来描述:</p>
<div class="math notranslate nohighlight">
\[g_Ls=frac{1}{n}\]</div>
<p>其中，I i LS (ρ)是一个指示函数，用来识别空隙阶段的变化区域：</p>
<div class="math notranslate nohighlight">
\[I_i^{Ls}(\rho)=(1-\bar{\rho})·exp(-c\left| \nabla{\tilde{\rho}} \right|^2)\]</div>
<p>要从铸造的最小线宽（lw）和最小间距（ls）确定ηe和ηd，以下关系保持:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\eta_e = \begin {cases} \frac{1}{4}(\frac{lw}{R})^2+\frac{1}{2}, &amp; \frac{lw}{R}∈[0,1]  \\  -\frac{1}{4}(\frac{lw}{R})^2+\frac{lw}{R}, &amp; \frac{lw}{R}∈[1,2]   \\ 1,   &amp; \frac{lw}{R}∈[2，∞）    \end {cases}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\eta_d = \begin {cases} \frac{1}{2}- \frac{1}{4}(\frac{ls}{R})^2, &amp; \frac{ls}{R}∈[0,1]  \\  1+\frac{1}{4}(\frac{ls}{R})^2-\frac{ls}{R}, &amp; \frac{ls}{R}∈[1,2]   \\ 0,   &amp; \frac{ls}{R}∈[2，∞）    \end {cases}\end{split}\]</div>
<p>这里的R是用户指定的圆锥形滤波器的半径。这允许人们任意选择滤波器的半径，并从上述关系中推导出后续的阈值参数（ηe和ηd）。选择更小的半径允许较小的特征，但代价是潜在地“加强”相应的优化问题（即，约束Hessian可能有较大的条件数）。ηe和ηd的典型值分别为0.75和0.25，对应于R = 2lw = 2ls。</p>
<p>最后，我们注意到线宽和线空间约束也对固体和空隙区域的相应最小曲率进行了隐式约束。假设使用圆形滤波器并且满足约束，得到的拓扑不能包含直径小于相应长度尺度的圆形元素（例如，固体区域的线宽和空隙区域的线间距）。因此，相应的最小曲率半径κw，s被定义为:</p>
<div class="math notranslate nohighlight">
\[k_{w,s} = \frac{l_{w,s} }{2}\]</div>
</section>
<section id="id16">
<h3>4.2 添加最小面积和封闭面积约束<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h3>
<p>接下来，是对二维平面的约束，首先，指示器函数识别违反最小面积约束的区域（“岛屿”）和违反最小封闭面积约束的区域（“洞”）。接下来，每个约束都将鼓励优化器通过局部侵蚀（对于岛屿）或局部扩张（对于孔洞）来消除破坏区域。下图说明了一个样本设计（图2(a)）上的最小面积约束函数，使用图像分割算法识别违反规则的区域（图2(c)），不违反规则的区域保留，违反的区域根据我们设计的大小进行约束（图2(b)）。
<span><div style="text-align: center;"></p>
<p><img alt="最小面积" src="../../../_images/4.2.png" /></p>
</div></span>
<center>图4.2 最小面积限制（a）原始样本 (b)约束后的样本（c）识别违反规则区域</center></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="../%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9D%97/contents.html" class="btn btn-neutral float-left" title="全局搜索优化算法" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../%E8%BF%9C%E5%9C%BA%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%9D%97/contents.html" class="btn btn-neutral float-right" title="远场传播模块" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, Rickey.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>